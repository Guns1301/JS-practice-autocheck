//! Метод forEach(callback)
// Перебирающий метод массива, который используется как замена циклов for и for...of при работе с коллекцией.
// 1.Поэлементно перебирает массив.
//2.Вызывает коллбек-функцию для каждого элемента массива.
//3.Ничего не возвращает.
//Аргументы коллбек-функции это значение текущего элемента element, его индекс index и сам исходный массив array. Объявлять можно только те параметры которые нужны, чаще всего это элемент, главное не забывать про их порядок.
function calculateTotalPrice(orderedItems) {
  let totalPrice = 0;
  // Пиши код ниже этой строки
orderedItems.forEach(function(orderedItem){
 totalPrice+= orderedItem 
   })
  return totalPrice;
}

// Единственным случаем, когда стоит использовать циклы for или for...of для перебора массива, это задачи с прерыванием выполнения цикла. Прервать выполнение метода forEach нельзя, он всегда перебирает массив до конца.

// у forEach есть два аргумента - это коллбэк и объект в контексте которого будет вызываться этот колбэк

// 2/44
function filterArray(numbers, value) {
    const filteredNumbers = [];
   
    numbers.forEach(function (numbers) {
    //   В большинстве методов, аргументами callback-функции являются значение элемента currentValue (первый параметр), позиция элемента index (второй параметр) и сам исходный массив array (третий параметр).
   if(numbers > value) {
   filteredNumbers.push(numbers);}})
    
    return filteredNumbers;
}
  
console.log(filterArray([1, 2, 3, 4, 5], 3))
console.log(filterArray([12, 24, 8, 41, 76], 38))


// 3/44

function getCommonElements(firstArray, secondArray) {
    const commonElements = [];
  
  firstArray.forEach(function(firstArray){
  if (secondArray.includes(firstArray)) {
        commonElements.push(firstArray);
      }
  })
    return commonElements;
}
  
console.log(getCommonElements([1, 2, 3], [2, 4])); //возвращает [2].
console.log(getCommonElements([10, 20, 30, 40], [4, 30, 17, 10, 40])) // возвращает [10, 30, 40].


// 4/44

// Стрелочные функции имеют сокращённый, более лаконичный синтаксис, что уменьшает объем кода, особенно когда функция маленькая или если она используется как коллбек.

//Все стрелки создаются как функциональное выражение, и если функция не анонимна, то она должна быть присвоена переменной.
const calculateTotalPrice = (quantity, pricePerItem) => {
  // Если параметров несколько, то они перечисляются через запятую в круглых скобках, между знаками равно = и стрелкой =>.
  return quantity * pricePerItem;
}



// 5 /44
// Если фигурные скобки есть, и функция должна возвращать какое-то значение, необходимо явно поставить return. Это называется явный возврат (explicit return). Такой синтаксис используется в том случае, если в теле функции нужно выполнить ещё какие-то инструкции кроме возврата значения.

const calculateTotalPrice = (quantity, pricePerItem) => 
    quantity * pricePerItem
   
    // Если фигурных скобок нет, то возвращается результат выражения стоящего после =>. Это называется неявный возврат (implicit return). В примере вернётся результат выражения сложения параметров a, b и c.

//Синтаксис неявного возврата сильно сокращает «шум» объявления функции с телом и возвращаемым выражением, но подходит только в случае когда в теле функции не нужно выполнять никаких дополнительных инструкций кроме возврата значения.

// 6/44

// Анонимные стрелочные функции отлично подходят как коллбеки для перебирающих методов массива из-за более краткого синтаксиса объявления, особенно если не нужно тело функции.
const calculateTotalPrice = (orderedItems) => {
  let totalPrice = 0;

  orderedItems.forEach((item) => {
    totalPrice += item;
  });

  return totalPrice;
}

// 7/44
const filterArray = (numbers, value) => {
    const filteredNumbers = [];
  
    numbers.forEach((number)=> {
      if (number > value) {
        filteredNumbers.push(number);
      }
    });
  
    return filteredNumbers;
}
  
// 8/44
const getCommonElements = (firstArray, secondArray) => {
    const commonElements = [];
  
    firstArray.forEach((element) => {
      if (secondArray.includes(element)) {
        commonElements.push(element);
      }
    });
    return commonElements;
}
  
// 9/44

const changeEven = (numbers, value) => {
    // Функция с побочными эффектами - это функция которая в процессе выполнения может изменять или использовать глобальные переменные, изменять значение аргументов ссылочного типа, выполнять операции ввода-вывода и т. п.
    const newArray = [...numbers];
  
  numbers.forEach(number => {
    if (number % 2 === 0) {
      newArray.splice(newArray.indexOf(number), 1, number + value);
      }
  });
  
  return newArray;
    // Пиши код выше этой строки
}
  

// 10/44

// Большинство перебирающих методов массива это чистые функции. Они создают новый массив, заполняют его, применяя к значению каждого элемента указанную коллбек-функцию, после чего возвращают этот новый массив.

// Поэлементно перебирает оригинальный массив.
//1. Не изменяет оригинальный массив.
//2. Результат работа коллбек-функции записывается в новый массив.
//3. Возвращает новый массив такой же длины.
//Его можно использовать для того, чтобы изменить каждый элемент массива. Оригинальный массив используется как эталон, на базе которого можно сделать другую коллекцию.

const planets = ['Земля', 'Марс', 'Венера', 'Юпитер'];
//Метод map(callback) используется для трансформации массива. Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив, который и будет результатом выполнения метода.
const planetsLengths = planets.map((planet) => planet.length);

console.log(planetsLengths);


// 11/44

const books = [
    { title: 'Последнее королевство', author: 'Бернард Корнуэлл', rating: 8.38 },
    { title: 'На берегу спокойных вод', author: 'Роберт Шекли', rating: 8.51 },
    { title: 'Сон смешного человека', author: 'Федор Достоевский', rating: 7.75 },
    { title: 'Красна как кровь', author: 'Ли Танит', rating: 7.94 },
    { title: 'Враг Божий', author: 'Бернард Корнуэлл', rating: 8.67 }
  ];
  // Используя метод map() можно перебрать массив объектов, и в коллбек-функции вернуть значение свойства каждого из них.
  
const titles = books.map(book => book.title);
  
// 12/44
// Метод flatMap(callback) аналогичен методу map(), но применяется в случаях, когда результат это многомерный массив который необходимо «разгладить».
const books = [
    {
      title: 'Последнее королевство',
      author: 'Бернард Корнуэлл',
      genres: ['приключения', 'историческое']
    },
    {
      title: 'На берегу спокойных вод',
      author: 'Роберт Шекли',
      genres: ['фантастика']
    },
    {
      title: 'Красна как кровь',
      author: 'Ли Танит',
      genres: ['ужасы', 'мистика']
    }
  ];
  // Он вызывает коллбек-функцию для каждого элемента исходного массива, а результат её работы записывает в новый массив. Отличие от map() в том, что новый массив «разглаживается» на глубину равную единице (одна вложенность). Этот разглаженный массив и есть результат работы flatMap().
const genres = books.flatMap((book) => book.genres);
  


// 13/44

const getUserNames = users => users.map(user => user.name);


// 14/44

const getUserEmails = users => users.map(user => user.email);

// 15/44 

// Метод filter(callback) используется для единственной операции - фильтрации массива, то есть когда необходимо выбрать более одного элемента из коллекции по какому-то критерию.

const numbers = [17, 24, 82, 61, 36, 18, 47, 52, 73];

const evenNumbers = numbers.filter(number => number %2 ===0 );
const oddNumbers = numbers.filter(number => number % 2 !== 0);
//1. Не изменяет оригинальный массив.
//2. Поэлементно перебирает оригинальный массив.
//3. Возвращает новый массив.
//4. Добавляет в возвращаемый массив элементы которые удовлетворяют условию коллбек-функции.
//5. Если коллбек вернул true элемент добавляется в возвращаемый массив.
//6. Если коллбек вернул false элемент не добавляется в возвращаемый массив.
//7. Если ни один элемент не удовлетворил условию, возвращает пустой массив.

console.log(evenNumbers);
console.log(oddNumbers);
// То есть метод filter вызывает коллбек-функцию для каждого элемента исходного массива и если результат её выполнения true, текущий элемент добавляет в новый массив.


// 16/44

// Используя метод filter() можно выполнить фильтрацию массива так, что в нём останутся только уникальные элементы. Этот приём работает только с массивом примитивных значений - не объектов

const books = [
    {
      title: 'Последнее королевство',
      author: 'Бернард Корнуэлл',
      genres: ['приключения', 'историческое']
    },
    {
      title: 'На берегу спокойных вод',
      author: 'Роберт Шекли',
      genres: ['фантастика', 'мистика']
    },
    {
      title: 'Красна как кровь',
      author: 'Ли Танит',
      genres: ['ужасы', 'мистика', 'приключения']
    }
  ];
  
const allGenres = books.flatMap((book) => book.genres);
// Задача заключается в том, чтобы сделать новый массив, в котором будут только уникальные предметы, то есть без повторений.
 const uniqueGenres = allGenres.filter(
   (genres, index, books) => books.indexOf(genres) === index);
    // Используя array.indexOf(course) выполняем поиск первого совпадения текущего элемента course и получаем его индекс в оригинальном массиве всех курсов. В параметре index хранится индекс текущего элемента course при переборе массива методом filter.Если результат indexOf() и значение index равны - это уникальный элемент, потому что это первый раз когда такое значение встречается в массиве и на текущей итерации фильтр обрабатывает именно его.

// 17/44

const books = [
  { title: 'Последнее королевство', author: 'Бернард Корнуэлл', rating: 8.38 },
  { title: 'На берегу спокойных вод', author: 'Роберт Шекли', rating: 8.51 },
  { title: 'Сон смешного человека', author: 'Федор Достоевский', rating: 7.75 },
  { title: 'Красна как кровь', author: 'Ли Танит', rating: 7.94 },
  { title: 'Враг Божий', author: 'Бернард Корнуэлл', rating: 8.67 }
];

const MIN_RATING = 8;
const AUTHOR = 'Бернард Корнуэлл';

// При работе с массивом объектов выполняется фильтрация по значению какого-то свойства. В результате получается новый массив отфильтрованных объектов.

const topRatedBooks = books.filter((book) => book.rating >= MIN_RATING);

const booksByAuthor = books.filter((book) =>  book.author === AUTHOR);


// 18/44
const getUsersWithEyeColor = (users, color) => users.filter(user => user.eyeColor === color);

// 19/44
const getUsersWithAge = (users, minAge, maxAge) => users.filter(user => user.age >= minAge && user.age < maxAge);

// 20/44

const getUsersWithFriend = (users, friendName) => {
  return users.filter((user) => user.friends.includes(friendName));
};

// 21/44
